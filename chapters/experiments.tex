\chapter{آزمایشات انجام شده}
\section{مجموعه داده}
MAPS یک \gls{dataset} از فایل‌های \gls{MIDI} و فایل‌های صوتی هم‌تراز آن‌ها است
که برای مسائل \gls{atm} و \gls{mpe} طراحی و آماده‌سازی شده است
\cite{emiya2009multipitch}. فایل‌های صوتی در شرایط محیطی مختلف ضبط شده‌اند و از
استاندارد CD تبعیت می‌کنند. به این معنی که هر نمونه ۱۶ بیت دقت دارد و نمونه
برداری با دقت ۴۴ کیلوهرتز انجام شده است. این \gls{dataset} شامل حدود ۶۵ ساعت
فایل صوتی است و حجم کل \gls{dataset} در حدود ۴۰ گیگابایت است. MAPS تحت مجوز
\rl{Creative Commons} به صورت عمومی منتشر شده است.

برای تولید MAPS ابتدا مجموعه‌ای عظیم از فایل‌ها \gls{MIDI} جمع‌آوری شده است. سپس
از فایل‌های \gls{MIDI} جمع‌آوری شده استفاده شده تا فایل صوتی متناظر هر کدام
تولید شود. برای تولید فایل‌های صوتی کاملا هم‌تراز با فایل‌های \gls{MIDI} از دو
روش استفاده شده است.

عمده فایل‌ها توسط نرم‌افزار ایجاد شده‌اند و از هیچ ساز فیزیکی برای تولید آن‌ها
استفاده نشده است. برای این مجموعه از فایل‌ها ابتدا فایل‌های \gls{MIDI} پشت هم
قرار داده شده‌اند تا فایل‌های \gls{MIDI} کمتر ولی با طولی بیشتر به دست آید. سپس
خروجی صوتی هر فایل توسط نرم‌افزار \lr{Steinberg’s Cubase SX} شبیه‌سازی شده است.
برای ایجاد تنوع در فایل‌های صوتی، نرم‌افزار جهت انجام شبیه‌سازی برای فایل‌های
مختلف از نمونه اجراهای پیانوهای مختلف و در شرایط محیطی متفاوت استفاده کرده است.
در نهایت فایل‌های صوتی ایجاد شده با توجه به فایل‌های \gls{MIDI} ابتدایی قطعه
قطعه شده‌اند تا اجرای متناظر هر فایل به دست آید. دلیل استفاده از فایل‌های
طولانی‌تر بجای استفاده از فایل‌های اصلی این بوده است که نرم‌افزار استفاده شده به
صورت اتوماتیک قابل کنترل نیست و برای هر ایجاد هر فایل نیز به دخالت انسانی است.

برای بخش دیگر از فایل‌های صوتی از یک پیانو Disklavier استفاده شده است. این
خانواده از پیانوها می‌توانند از طریق ارتباط \gls{MIDI} فشرده شدن هر کلاویه را با
قدرت‌های مختلف شبیه‌سازی کنند. در نتیجه مانند این است که یک نوازنده با قدرتی
فراانسانی هر کلاویه را در زمان درست و با \gls{velocity} مشخص شده فشار دهد و
دقیقا در زمان خواسته شده آن‌را رها کند. همچنین برای ایجاد تنوع در فایل‌های صوتی
ضبط شده در گروهی از فایل‌ها میکروفن در فاصله نیم‌متری ساز قرار داده شده است و در
گروه دیگر میکروفن در فاصله‌ای مابین ۳ تا ۴ متری ساز قرار دارد.

نکته قابل توجه این است که فایل‌های \gls{MIDI} که برای تولید صوت در روش‌های مختلف
استفاده شده است ممکن است اشتراک داشته باشند. در نتیجه از یک قطعه ممکن است چندین
اجرای مختلف موجود باشد.

در این \gls{dataset} چهار دسته فایل \gls{MIDI} و اجراهای متناظر آن‌ها وجود دارد:
\begin{enumerate}
    \item فقط شامل اجرای مجرد نت‌های مختلف و اجراهای کوتاه
    \gls{monophonic} است. از این بخش از \gls{dataset} می‌تواند برای روش‌هایی
    مانند \gls{nmf} که نیاز به اجرای جدای نت‌ها دارند استفاده کرد.

    \item  شامل اجرای \glspl{chord} می‌شود که نت‌ها با هم هیچ ارتباط
    موسیقیایی ندارند و به صورت تصادفی در کنار هم قرار گرفته‌اند. این بخش از
    \gls{dataset} برای آزمایش عملکرد مدل‌های \gls{mpe} بدون استفاده‌ای از دانش
    موسیقی مناسب است.

    \item شامل اجرا \glspl{chord} رایج در موسیقی‌های غربی، مانند \glspl{chord}
    جز و یا \glspl{chord} کلاسیک، است. در نتیجه این بخش از \gls{dataset} برای
    سیستم‌هایی که از دانش موسیقیایی برای افزایش  دقت استفاده می‌کنند مناسب است.

    \item شامل ۲۳۸ قطعه موسیقی کلاسیک هست که در زمان انتشار \gls{dataset} تحت
    مجوز \rl{Creative Commons} منتشر شده بودند. تمام این فایل‌ها به صورت دستی
    پردازش شده‌اند تا هر نت کشش و \gls{velocity} مناسب را داشته باشد. این بخش از
    \gls{dataset} برای سیستم‌های \gls{atm} مناسب است.
\end{enumerate}

در این پایان‌نامه فقط از فایل‌های صوتی ضبط شده از اجرای Disklavier برای ارزیابی
استفاده شده است. دلیل این انتخاب این است که در دنیای واقعی هدف آوانویسی اجراهای
یک ساز واقعی است و اجراهای مصنوعی که توسط نرم‌افزار تولید شده‌اند اکثر جزییات یک
ساز واقعی را ندارند. همچنین از هیچ قطعه‌ای که در بخش ارزیابی وجود دارد، برای
آموزش هم استفاده نشده است تا سیستم فقط بر روی قطعات کاملا جدید ارزیابی شود. در
نهایت تنها از قطعات کامل در MAPS استفاده شده است.

علارغم تمام تلاش‌های انجام شده در تهیه این \gls{dataset} همچنان چندین مشکل وجود
دارد. مشکل اول حجم کم داده است. برای مثال این \gls{dataset} تنها شامل ۶۰ نمونه
از اجرای ضبط شده واقعی است که با توجه به ماهیت مسئله بسیار محدود است. همچنین بجز
حجم کم داده، در چندین مورد فایل‌های \gls{MIDI} با نسخه‌های ضبط شده هم‌خوانی کامل
ندارند. برای مثال در قطعات مختلف اجرا نشدن نت‌های با \gls{velocity} پایین کاملا
محسوس است.

\section{معیارهای ارزیابی}
معیارهای استفاده شده برای ارزیابی بسیار نزدیک به معیارهای پیشنهاد شده در مسابقات
MIREX است که توسط کتابخانه \lr{mir-eval} \cite{raffel2014mir_eval} پیاده‌سازی
شده‌اند.

برای ارزیابی ابتدا از \gls{dataset} مجموعه‌ای از چهارتایی‌های مرتب مرتبط با هر
قطعه استخراج می‌شود. هر کدام از این چهارتایی‌های مرتب نشان دهنده یک نت هستند و
اعضای آن به ترتیب فرکانس نت، زمان شروع، زمان پایان و \gls{velocity} نت را نشان
می‌دهند. به این ساختار ذخیره‌سازی موسیقی دنباله نت می‌گوییم. همچنین پس از انجام
آوانویسی توسط مدل، خروجی مدل از ساختار \gls{pianoroll} توسط الگوریتمی که در
ادامه بحث می‌شود به دنباله نت تبدیل می‌شود.

برای ارزیابی نیاز هست که تشخیص دهیم که کدام یک از نت‌های تشخیص داده شده توسط مدل
واقعا در قطعه حضور دارند، چه تعداد حضور ندارند و مدل چه تعداد از نت‌ها را تشخیص
نداده است. همچنین با توجه به این که میزان کمی خطا در زمان‌ها و یا فرکانس نت‌های
تشخیص داده شده طبیعی است، معیارهای استفاده شده نیاز به مقداری انعطاف‌پذیری نیز
دارند.

به این منظور گرافی دو بخشی ایجاد می‌شود که راس‌های یک بخش نت‌های استراخ شده از
\gls{dataset} هستند و راس‌های بخش دیگر نت‌های تشخیص داده شده توسط مدل هستند. در
صورتی که بتوان دو راس مختلف از دو بخش را برابر دانست بین‌ آن‌ها یالی قرار
می‌دهیم در غیر این صورت دو راس به هم مرتبط نیستند. همچنین شرط برابر بودن نت‌ها
وابسطه به معیار متفاوت است که در ادامه برای هر معیار این شرط بررسی می‌شود.

پس از تشکیل گراف ذکر شده، تطابق بیشینه گراف محاسبه می‌شود تا مشخص شود که چه
نت‌هایی به درستی تشخیص داده شده‌اند و چه نت‌های اشتباه تشخیص داده شده‌اند و یا
تشخیص داده نشده‌اند. پس از محاسبه این تطابق می‌توان از طریق روابط زیر مقادیر
\gls{precision}، \gls{recall} و F1 را برای معیار مورد نظر محاسبه کرد:
\begin{equation}
    precision = \frac{TP}{TP + FP}
\end{equation}
\begin{equation}
    recall = \frac{TP}{TP + FN}
\end{equation}
\begin{equation}
    F1 = 2 \frac{precision . recall}{precision + recall}
\end{equation}

$TP$ تعداد نت‌هایی هست که به درستی تشخیص داده شده‌اند که برابر با اندازه تطابق
محاسبه شده است. $FP$ نت‌هایی هستند که مدل تشخیص داده است ولی واقعا وجود ندارند.
این عدد برابر با راس‌های از بخش مربوط به نت‌های تشخیص داده شده توسط مدل هستند که
در تطابق نیستند. همچنین $FN$ تعداد نت‌هایی هست که مدل نتوانسته تشخیص دهد. تعداد
این نت‌ها برابر با راس‌هایی از بخش استخراج شده از \gls{dataset} است که عضو تطابق
نیستند.

شرط برابر فرض شدن دو نت با توجه به معیار مورد نظر متفاوت است. معیار اول فقط به
شروع نت‌ها تشخیص داده شده اهمیت می‌دهد. در نتیجه دو نت یکسان فرض می‌شوند اگر
\gls{pitch} آن‌ها کمتر از ربع‌پرده اختلاف داشته باشد و همچنین تفاوت زمان شروع
آن‌ها کمتر از ۵۰ میلی‌ثانیه باشد.

معیار بعدی علاوه بر شروع نت‌ها به زمان پایان نت‌ها نیز اهمیت می‌دهد. در نتیجه
برای برابر فرض شدن دو نت علاوه در شروط قبلی، دو نت باید اختلاف زمان پایانشان
کمتر از بیشینه ۵۰ میلی‌ثانیه و یک پنچم طول نت مرجع باشد.

بررسی صحت \gls{velocity} تشخیص داده برای هر نت بسیار پیچیده‌تر است. بر خلاف زمان
شروع و یا پایان \gls{velocity} یک ویژگی کاملا نسبی هست. همچنین دو اجرای مختلف یک
قطعه می‌توانند کاملا صحیح باشند ولی \gls{velocity} نت‌های اجرا شده کاملا متفاوت
باشد. برای مقابله با این مشکل ابتدا تطابق با توجه به \gls{pitch} و زمان شروع و
پایان نت‌ها محاسبه می‌شود. سپس \gls{velocity} نت‌ها مرجع بر بیشترین
\gls{velocity} موجود در قطعه تقسیم می‌شود تا مقادیر \gls{velocity} بین صفر و یک
قرار گیرد. سپس \gls{linear regression} زیر حل می‌شود:
\begin{equation}
    m, b := \underset{m, b}{argmin} \sum_{i=1}^{M} (v_r(i) - (mv_e(i) + b))^2
\end{equation}
که $M$ اندازه تطابق محاسبه شده است. $v_r(i)$ \gls{velocity} نت مرجع $i$ام در
تطابق است و $v_e(i)$ \gls{velocity} نت $i$ام تشخیص داده شده در تطابق است.

پس از محاسبه ضرایب $m$ و $b$ از رابطه زیر استفاده می‌شود مقدار جدید
\gls{velocity} نت‌های تشخیص داده شده توسط مدل محاسبه شود:
\begin{equation}
    v_e^\prime (i) := mv_e(i) + b
\end{equation}

حال در صورتی که اختلاف $v_r(i)$ با $v_e^\prime(i)$ کمتر از یک دهم باشد یال $i$ام
در تطابق می‌ماند در غیر این صورت حذف می‌شود. در نهایت مقادیر \gls{precision}،‌
\gls{recall} و \lr{F1} برای تطابق به روز شده محاسبه می‌شود.

\section{الگوریتم تبدیل MIDI به دنباله‌ی نت}
اطلاعات در فایل‌های \gls{MIDI} به شکل دنباله‌ای از رخدادها ذخیره می‌شوند. هر
رخداد از سه بایت تشکیل شده که شامل اطلاعاتی همچنون نوع رخداد و فاصله زمانی از
رخداد قبلی می‌شود. مهم‌ترین این رخدادها رخدادهای فعال شدن و غیر فعال شدن نت‌ها
هستند که اطلاعات \gls{velocity} نت را نیز شامل می‌شوند. همچنین در پیانو رخداد
تغییر وضعیت پدال \gls{sustain} نیز اهمیت زیادی دارد.

پدال \gls{sustain} در پیانو به این شکل عمل می‌کند که در زمان فشرده بودن پلاد حتی
اگر کلاویه توسط نوازنده رها شود، نت همچنان فعال می‌ماند. نت فعال تنها در صورت
تمام می‌شود نوازنده مجددا همان کلاویه را فشار دهد یا پدال \gls{sustain} را رها
کند. در نتیجه برای تولید دنباله‌ی نت از فایل \gls{MIDI} توجه به تغییرات پدال
\gls{sustain} لازم است.

در شبه کدی که در ادامه آمده است الگوریتم تبدیل فایل \gls{MIDI} به دنباله‌ی نت
نشان داده شده است.

\begin{algorithm}
\caption{تبدیل \gls{MIDI} به دنباله‌ی نت}
\begin{algorithmic}
\begin{latin}
    \Require $midi$
    \Ensure $notesequence$
    \State $notesequence \leftarrow \emptyset$
    \State $actives \leftarrow \emptyset$
    \State $time \leftarrow 0$
    \State $sustain \leftarrow false$
    \For {$event$ in $midi$}
        \State $time \leftarrow time + event.delay$
        \If {$event.type$ is $NoteOn$}
            \If {$sustain$ is $true$}
                \For {$note$ in $actives$}
                    \If {$note.pitch$ is $event.value$}
                        \State $note.offset \leftarrow time$
                        \State $actives \leftarrow actives \setminus \{note\}$
                        \State $notesequence \leftarrow notesequence \cup \{note\}$
                    \EndIf
                \EndFor
            \EndIf
            \State $note \leftarrow Note()$
            \State $note.pitch \leftarrow event.value$
            \State $note.velocity \leftarrow event.velocity$
            \State $note.onset \leftarrow time$
            \State $actives \leftarrow actives \cup \{note\}$
        \ElsIf {$event.type$ is $NoteOff$}
            \For {$note$ in $actives$}
                \If {$note.pitch$ is $event.value$}
                    \State $note.offset \leftarrow time$
                    \If {$sustain$ is $false$}
                        \State $actives \leftarrow actives \setminus \{note\}$
                        \State $notesequence \leftarrow notesequence \cup \{note\}$
                    \EndIf
                \EndIf
            \EndFor
        \ElsIf {$event.type$ is $SustainChange$ and $event.value \geq 64$}
            \State $sustain \leftarrow true$
        \ElsIf {$event.type$ is $SustainChange$ and $event.value < 64$}
            \State $sustain \leftarrow false$
\algstore{miditonotesequence}
\end{latin}
\end{algorithmic}
\end{algorithm}
\setcounter{algorithm}{0}
\begin{algorithm}
\caption{ادامه تبدیل \gls{MIDI} به دنباله‌ی نت}
\begin{algorithmic}
\begin{latin}
\algrestore{miditonotesequence}
            \For {$note$ in $actives$}
                \If {$note.offset$ is not $null$}
                    \State $note.offset \leftarrow time$
                    \State $actives \leftarrow actives \setminus \{note\}$
                    \State $notesequence \leftarrow notesequence \cup \{note\}$
                \EndIf
            \EndFor
        \EndIf
    \EndFor
    \For {$note$ in $actives$}
        \State $note.offset \leftarrow time$
        \State $actives \leftarrow actives \setminus \{note\}$
        \State $notesequence \leftarrow notesequence \cup \{note\}$
    \EndFor
\end{latin}
\end{algorithmic}
\end{algorithm}

\section{الگوریتم تبدیل دنباله‌ی نت به رول پیانو}
هر \gls{pianoroll} شامل ۴ ماتریس است که به ترتیب نشان‌دهنده فعال بودن نت، شروع
نت، پایان نت و \gls{velocity} نت می‌باشند. هر ماتریس ۸۸ سطر دارد که متناظر با ۸۸
کلاویه پپانو است. همچنین هر ستون این ماتریس‌ها نماینده یک فرم می‌باشد.

برای تبدیل کافی است تا نت‌ها به ترتیب زمان شروع مرتب شوند. سپس زمان شروع و پایان
هر نت بر طول هر فرم، که در این پایان‌نامه برابر ۳۲ میلی‌ثانیه است، تقسیم شود تا
شماره ستون متناظر به دست آید. سپس کافی هست در هر ماتریس درایه‌های متناسب یک شوند
و بقیه درایه‌ها صفر بمانند. همچنین برای ماتریس مربوط به \gls{velocity} نت‌ها
مقدار درایه برابر با \gls{velocity} نت تقسیم بر بیشینه \gls{velocity} قطعه است.

شبه کد زیر الگوریتم تبدیل دنباله‌ی نت به \gls{pianoroll} را نشان داده است.

\begin{algorithm}
\caption{تبدیل دنباله‌ی نت به \gls{pianoroll}}
\begin{algorithmic}
\begin{latin}
    \Require $frame\_duration$, $notesequence$
    \Ensure $actives$, $onsets$, $offsets$, $velocities$
    \State $notesequence\_duration \leftarrow$ max of all offsets
    \State $max\_velocity \leftarrow$ max of all velocities
    \State $num\_frames \leftarrow \lfloor notesequence\_duration / frame\_duration \rfloor + 1$
    \State $actives \leftarrow$ zero matrix of size $88 \times num\_frames$
    \State $onsets \leftarrow$ zero matrix of size $88 \times num\_frames$
    \State $offsets \leftarrow$ zero matrix of size $88 \times num\_frames$
    \State $velocities \leftarrow$ zero matrix of size $88 \times num\_frames$
    \State sort $notesequence$ by $onset$
    \For {$note$ in $notesequence$}
        \State $pitch \leftarrow note.pitch - 21$
        \If {$pitch < 0$ or $pitch > 87$}
            \State continue
        \EndIf
        \State $start \leftarrow \lfloor note.onset / frame\_duration \rfloor$
        \State $end \leftarrow \lfloor note.offset / frame\_duration \rfloor$
        \If {$start$ is $end$}
            \State continue
        \EndIf
        \State $actives_{pitch, start:end} \leftarrow 1$
        \State $onsets_{pitch, start} \leftarrow 1$
        \State $offsets_{pitch, end} \leftarrow 1$
        \State $velocities_{pitch, start:end} \leftarrow note.velocity / max\_velocity$
    \EndFor
\end{latin}
\end{algorithmic}
\end{algorithm}

\section{الگوریتم تبدیل رول پیانو به دنباله‌ی نت}
برای ارزیابی عملکرد مدل لازم هست تا \gls{pianoroll} تولید شده توسط مدل به
دنباله‌ی نت تبدیل شود. برای این تبدیل باید به ازای هر نت فعال شدن و در جهت
فرم‌ها حرکت کنیم. اگر مدل شروع شدن نتی را تشخیص داد حتی اگر در آن فرم نت غیر
فعال تشخیص داده شود نت فعال فرض می‌شود. همچنین در صورتی که مدل تمام شدن نتی را
تشخیص دهد حتی در صورت تشخیص فعال بودن نت در آن فرم، نت غیر فعال فرض می‌شود.
همچنین اگر نتی فعال بود و مدل شروع دوباره‌ای برای آن تشخیص دهد، نت قبلی تمام شده
فرض می‌شود و مجددا همان نت شروع می‌شود.

در شبه کد زیر الگوریتم تبدیل \gls{pianoroll} به دنباله‌ی نت نشان داده شده است.
\begin{algorithm}
\caption{تبدیل \gls{pianoroll} به دنباله‌ی نت}
\begin{algorithmic}
\begin{latin}
    \Require $actives$, $onsets$, $offsets$, $velocities$, $frame\_duration$
    \Ensure $notesequence$
    \State $notesequence \leftarrow \emptyset$
    \State $num\_frames \leftarrow actives.shape[1]$
    \For {$pitch$ from $0$ to $88$}
        \State $start \leftarrow null$
        \For {$frame$ from $0$ to $num\_frames$}
            \State $is\_onset \leftarrow onsets_{pitch, frame} \geq 0.5$
            \State $is\_previous\_onset \leftarrow false$
            \If {$frame > 0$}
                \State $is\_previous\_onset \leftarrow onsets_{pitch, frame-1} \geq 0.5$
            \EndIf
            \State $is\_offset \leftarrow offsets_{pitch, frame} \geq 0.5$
            \State $is\_active \leftarrow actives_{pitch, frame} \geq 0.5$
            \State $is\_active \leftarrow is\_active$ and not $is\_offset$
            \State $is\_active \leftarrow is\_active$ or $is\_onset$
            \If {$is\_onset$ and $start$ is $null$}
                \State $start \leftarrow frame$
            \ElsIf {$is\_onset$ and not $is\_previous\_onset$}
                \State $note \leftarrow Note()$
                \State $note.pitch \leftarrow pitch$
                \State $note.onset \leftarrow start * frame\_duration$
                \State $note.offset \leftarrow frame * frame\_duration$
                \State $note.velocity \leftarrow max(min(velocities_{pitch, start}, 1), 0) * 80 + 10$
                \State $start \leftarrow frame$
            \ElsIf {not $is_active$ and $start$ is not $null$}
                \State $note \leftarrow Note()$
                \State $note.pitch \leftarrow pitch$
                \State $note.onset \leftarrow start * frame\_duration$
                \State $note.offset \leftarrow frame * frame\_duration$
                \State $note.velocity \leftarrow max(min(velocities_{pitch, start}, 1), 0) * 80 + 10$
                \State $start \leftarrow null$
            \EndIf
            \If {$start$ is not $null$}
                \State $note \leftarrow Note()$
                \State $note.pitch \leftarrow pitch$
                \State $note.onset \leftarrow start * frame\_duration$
                \State $note.offset \leftarrow num\_frames * frame\_duration$
                \State $note.velocity \leftarrow max(min(velocities_{pitch, start}, 1), 0) * 80 + 10$
            \EndIf
        \EndFor
    \EndFor
\end{latin}
\end{algorithmic}
\end{algorithm}
